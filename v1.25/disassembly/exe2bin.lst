CODE:0000                   ;
CODE:0000                   ; ╔═════════════════════════════════════════════════════════════════════════╗
CODE:0000                   ; ║     This file is generated by The Interactive Disassembler (IDA)        ║
CODE:0000                   ; ║     Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>           ║
CODE:0000                   ; ║                      Licensed to: Freeware version                      ║
CODE:0000                   ; ╚═════════════════════════════════════════════════════════════════════════╝
CODE:0000                   ;
CODE:0000                   ; Input MD5   : 97D848F6216DFB22428793E8F09877FF
CODE:0000
CODE:0000                   ; File Name   : ...\EXE2BIN.EXE
CODE:0000                   ; Format      : MS-DOS executable (EXE)
CODE:0000                   ; Base Address: 1000h Range: 10000h-10351h Loaded length: 2CCh
CODE:0000                   ; Entry Point : 1000:0
CODE:0000
CODE:0000                                   .686p
CODE:0000                                   .mmx
CODE:0000                                   .model large
CODE:0000
CODE:0000                   ; ═══════════════════════════════════════════════════════════════════════════
CODE:0000
CODE:0000                   ; Segment type: Pure code
CODE:0000                   CODE            segment byte public 'CODE' use16
CODE:0000                                   assume cs:CODE
CODE:0000                   ;
CODE:0000                   ; * Microsoft has published the sources to EXE2BIN from
CODE:0000                   ; * MS-DOS v2.0.  This DOS v1 EXE2BIN is basically an
CODE:0000                   ; * ancestor of the DOS v2 EXE2BIN; it uses DOS v1 File
CODE:0000                   ; * Control Blocks (FCBs) instead of modern file
CODE:0000                   ; * descriptors.
CODE:0000                   ; *
CODE:0000                   ; * For this disassembly, I have lifted most code
CODE:0000                   ; * comments from the v2 EXE2BIN sources.  However, I
CODE:0000                   ; * have also added a few clarifications here and
CODE:0000                   ; * there; these are marked with braces {}.  Comments
CODE:0000                   ; * about syscall parameters were added automatically
CODE:0000                   ; * by IDA.  -- tkchia
CODE:0000                   ;
CODE:0000                                   assume es:nothing, ss:STACK, ds:nothing, fs:nothing, gs:nothing
CODE:0000
CODE:0000                   ; ███████████████ S U B R O U T I N E ███████████████████████████████████████
CODE:0000
CODE:0000
CODE:0000                                   public LOCATE
CODE:0000                   LOCATE          proc far
CODE:0000 BE 81 00                          mov     si, 81h ; 'ü'
CODE:0003 BF 9B 00                          mov     di, offset FILE1_FCB
CODE:0006 1E                                push    ds              ; * Push return address to DS:0
CODE:0006                                                           ; * {i.e. PSP:0}
CODE:0007 33 C0                             xor     ax, ax
CODE:0009 50                                push    ax
CODE:000A 8B 1E 02 00                       mov     bx, ds:2        ; * Get size of memory
CODE:000E BA 1C 10                          mov     dx, seg DATA
CODE:0011 8E C2                             mov     es, dx
CODE:0013                                   assume es:DATA
CODE:0013 B8 09 29                          mov     ax, 2909h       ; * {Parse source file name into FCB;
CODE:0013                                                           ; * use .EXE as default extension}
CODE:0016 CD 21                             int     21h             ; DOS - PARSE FILENAME
CODE:0016                                                           ; DS:SI -> string to parse
CODE:0016                                                           ; ES:DI -> buffer to fill with unopened FCB
CODE:0016                                                           ; AL = bit mask to control parsing
CODE:0018 56                                push    si
CODE:0019 1E                                push    ds              ; * {Copy only drive letter & filename
CODE:0019                                                           ; * portions of source FCB to
CODE:0019                                                           ; * destination FCB; use .BIN as
CODE:0019                                                           ; * default destination extension}
CODE:001A BE 9B 00                          mov     si, offset FILE1_FCB
CODE:001D BF C0 00                          mov     di, offset FILE2_FCB
CODE:0020 8E DA                             mov     ds, dx
CODE:0022                                   assume ds:DATA
CODE:0022 B9 09 00                          mov     cx, 9
CODE:0025 F3 A4                             rep movsb
CODE:0027 1F                                pop     ds
CODE:0028                                   assume ds:nothing
CODE:0028 5E                                pop     si              ; * {Parse destination file name (if
CODE:0028                                                           ; * given) into FCB}
CODE:0029 BF C0 00                          mov     di, offset FILE2_FCB
CODE:002C B8 0F 29                          mov     ax, 290Fh
CODE:002F CD 21                             int     21h             ; DOS - PARSE FILENAME
CODE:002F                                                           ; DS:SI -> string to parse
CODE:002F                                                           ; ES:DI -> buffer to fill with unopened FCB
CODE:002F                                                           ; AL = bit mask to control parsing
CODE:0031 8E DA                             mov     ds, dx
CODE:0033                                   assume ds:DATA
CODE:0033 B4 0F                             mov     ah, 0Fh         ; * Open input file
CODE:0035 BA 9B 00                          mov     dx, offset FILE1_FCB
CODE:0038 CD 21                             int     21h             ; DOS - OPEN DISK FILE
CODE:0038                                                           ; DS:DX -> FCB
CODE:0038                                                           ; Return: AL = 00h file found, FFh file not found
CODE:003A 0A C0                             or      al, al
CODE:003C 74 12                             jz      short EXELOAD
CODE:003E BA 0A 00                          mov     dx, offset NOTFND ; "File not found$"
CODE:0041
CODE:0041                   XERROR:                                 ; CODE XREF: LOCATE+49↓j
CODE:0041                                                           ; LOCATE:ERRORJ↓j ...
CODE:0041 B4 09                             mov     ah, 9
CODE:0043 CD 21                             int     21h             ; DOS - PRINT STRING
CODE:0043                                                           ; DS:DX -> string terminated by "$"
CODE:0045 CB                                retf                    ; * Return to PSP:0
CODE:0046                   ; ───────────────────────────────────────────────────────────────────────────
CODE:0046
CODE:0046                   TOOBIG:                                 ; CODE XREF: LOCATE+78↓j
CODE:0046                                                           ; LOCATE+92↓j ...
CODE:0046 BA 19 00                          mov     dx, offset NOROOM ; "Insufficient memory$"
CODE:0049 EB F6                             jmp     short XERROR
CODE:004B                   ; ───────────────────────────────────────────────────────────────────────────
CODE:004B
CODE:004B                   BADEXE:                                 ; CODE XREF: LOCATE+6D↓j
CODE:004B                                                           ; LOCATE+150↓j ...
CODE:004B BA 82 00                          mov     dx, offset CANTFIX ; "File cannot be converted$"
CODE:004E
CODE:004E                   ERRORJ:                                 ; CODE XREF: LOCATE:ERRORNZ↓j
CODE:004E EB F1                             jmp     short XERROR
CODE:0050                   ; ───────────────────────────────────────────────────────────────────────────
CODE:0050
CODE:0050                   EXELOAD:                                ; CODE XREF: LOCATE+3C↑j
CODE:0050 BA EC 00                          mov     dx, offset MAGIC_OR_RELPT ; * Read {.EXE} header in here
CODE:0053 B4 1A                             mov     ah, 1Ah
CODE:0055 CD 21                             int     21h             ; DOS - SET DISK TRANSFER AREA ADDRESS
CODE:0055                                                           ; DS:DX -> disk transfer buffer
CODE:0057 C7 06 A9 00 01 00                 mov     FILE1_FCB.FCB_RC, 1
CODE:005D B9 1A 00                          mov     cx, 1Ah         ; * Amount of header info we need
CODE:0060 BA 9B 00                          mov     dx, offset FILE1_FCB
CODE:0063 B4 27                             mov     ah, 27h
CODE:0065 CD 21                             int     21h             ; DOS - RANDOM BLOCK READ
CODE:0065                                                           ; DS:DX -> FCB
CODE:0065                                                           ; CX = number of records to be read
CODE:0067 81 3E EC 00 4D 5A                 cmp     MAGIC_OR_RELPT, 5A4Dh ; * Check signature word
CODE:006D 75 DC                             jnz     short BADEXE
CODE:006F A1 F4 00                          mov     ax, HEADSIZ     ; * Size of header in paragraphs
CODE:0072 05 1F 00                          add     ax, 1Fh         ; * Round up first
CODE:0072                                                           ; * {DOS v1 COMMAND.COM actually
CODE:0072                                                           ; * requires an .EXE header to
CODE:0072                                                           ; * be a multiple of a page
CODE:0072                                                           ; * size (200H bytes), and will
CODE:0072                                                           ; * automatically round up any
CODE:0072                                                           ; * non-multiples (!); DOS v2
CODE:0072                                                           ; * handles .EXE headers in the
CODE:0072                                                           ; * kernel and does not do any
CODE:0072                                                           ; * such rounding up; but v2's
CODE:0072                                                           ; * EXE2BIN still (kind of
CODE:0072                                                           ; * erroneously) rounds up
CODE:0072                                                           ; * header sizes}
CODE:0075 3D 00 10                          cmp     ax, 1000h       ; * Must not be >= 64K
CODE:0078 73 CC                             jnb     short TOOBIG
CODE:007A 25 E0 FF                          and     ax, 0FFE0h
CODE:007D B1 04                             mov     cl, 4
CODE:007F D3 E0                             shl     ax, cl          ; * Header size in bytes
CODE:0081 A3 BC 00                          mov     word ptr FILE1_FCB.FCB_RN, ax
CODE:0084 86 C4                             xchg    al, ah
CODE:0086 D1 E8                             shr     ax, 1           ; * Convert to pages
CODE:0088 8B 16 F0 00                       mov     dx, SIZ_OR_PAGES ; * Total size of {.EXE} file in
CODE:0088                                                           ; * 512-byte pages
CODE:008C 2B D0                             sub     dx, ax          ; * Size of program {sans header}
CODE:008C                                                           ; * in pages
CODE:008E 81 FA 80 00                       cmp     dx, 80h ; 'Ç'   ; * Fit in 64K?
CODE:0092 73 B2                             jnb     short TOOBIG
CODE:0094 86 F2                             xchg    dh, dl
CODE:0096 D1 E2                             shl     dx, 1           ; * Convert pages to bytes
CODE:0098 A1 EE 00                          mov     ax, LASTP_OR_RELSEG ; * Get count of bytes in last page
CODE:009B 0B C0                             or      ax, ax          ; * If zero, use all of last page
CODE:009D 74 0B                             jz      short WHOLEP
CODE:009F 3D 04 00                          cmp     ax, 4           ; * Produced by old linker?
CODE:00A2 74 06                             jz      short WHOLEP    ; * If so, use all of last page too
CODE:00A4 81 EA 00 02                       sub     dx, 200h        ; * Subtract last page
CODE:00A8 03 D0                             add     dx, ax          ; * Add in byte count for last page
CODE:00AA
CODE:00AA                   WHOLEP:                                 ; CODE XREF: LOCATE+9D↑j
CODE:00AA                                                           ; LOCATE+A2↑j
CODE:00AA 89 16 F0 00                       mov     SIZ_OR_PAGES, dx
CODE:00AE 83 C2 0F                          add     dx, 0Fh
CODE:00B1 D3 EA                             shr     dx, cl          ; * Convert bytes to paragraphs
CODE:00B3 BD 35 10                          mov     bp, seg LOAD
CODE:00B6 03 D5                             add     dx, bp          ; * Size + start = minimum
CODE:00B6                                                           ; * memory (paragr.)
CODE:00B8 3B D3                             cmp     dx, bx          ; * Enough memory? {bx = [PSP:2]}
CODE:00BA 77 8A                             ja      short TOOBIG
CODE:00BC BA 82 00                          mov     dx, offset CANTFIX ; "File cannot be converted$"
CODE:00BF A1 FA 00                          mov     ax, INITSS
CODE:00C2 0B 06 FC 00                       or      ax, INITSP
CODE:00C6 0B 06 02 01                       or      ax, INITCS
CODE:00CA
CODE:00CA                   ERRORNZ:                                ; CODE XREF: LOCATE+D6↓j
CODE:00CA                                                           ; LOCATE+E5↓j
CODE:00CA 75 82                             jnz     short ERRORJ    ; * Must not have SS, SP, or
CODE:00CA                                                           ; * CS to init.
CODE:00CC A1 00 01                          mov     ax, INITIP
CODE:00CF 0B C0                             or      ax, ax          ; * If IP = 0, do binary fix
CODE:00D1 74 14                             jz      short BINFIX
CODE:00D3 3D 00 01                          cmp     ax, 100h        ; * .COM file must be
CODE:00D3                                                           ; * set up for CS:100H
CODE:00D6 75 F2                             jnz     short ERRORNZ
CODE:00D8 FE 06 BD 00                       inc     byte ptr FILE1_FCB.FCB_RN+1 ; * Chop off first 100H
CODE:00DC 29 06 F0 00                       sub     SIZ_OR_PAGES, ax ; * {Calculate} decreased size
CODE:00E0 83 3E F2 00 00                    cmp     RELCNT, 0       ; * {.COM files} must have no fixups
CODE:00E0                                                           ; * {(.BIN files can have them)}
CODE:00E5 75 E3                             jnz     short ERRORNZ
CODE:00E7
CODE:00E7                   BINFIX:                                 ; CODE XREF: LOCATE+D1↑j
CODE:00E7 33 DB                             xor     bx, bx          ; * Initialize fixup segment
CODE:00E9 83 3E F2 00 00                    cmp     RELCNT, 0       ; * See if segment fixups needed
CODE:00EE 74 45                             jz      short LOADEXE
CODE:00F0
CODE:00F0                   GETSEG:                                 ; CODE XREF: LOCATE+10C↓j
CODE:00F0                                                           ; LOCATE+133↓j
CODE:00F0 BA 59 00                          mov     dx, offset PROMPT ; "Fix-ups needed - base segment (hex): $"
CODE:00F3 B4 09                             mov     ah, 9
CODE:00F5 CD 21                             int     21h             ; DOS - PRINT STRING
CODE:00F5                                                           ; DS:DX -> string terminated by "$"
CODE:00F7 B4 0A                             mov     ah, 0Ah
CODE:00F9 BA E5 00                          mov     dx, offset INBUF ; * Get user response
CODE:00FC CD 21                             int     21h             ; DOS - BUFFERED KEYBOARD INPUT
CODE:00FC                                                           ; DS:DX -> buffer
CODE:00FE BA 7F 00                          mov     dx, offset CRLF ; "\r\n$"
CODE:0101 B4 09                             mov     ah, 9
CODE:0103 CD 21                             int     21h             ; DOS - PRINT STRING
CODE:0103                                                           ; DS:DX -> string terminated by "$"
CODE:0105 BE E7 00                          mov     si, (offset INBUF+2)
CODE:0108 C6 44 FF 00                       mov     byte ptr [si-1], 0 ; * Any digits?
CODE:010C 74 E2                             jz      short GETSEG
CODE:010E
CODE:010E                   DIGLP:                                  ; CODE XREF: LOCATE+12D↓j
CODE:010E AC                                lodsb
CODE:010F 2C 30                             sub     al, '0'
CODE:0111 72 1C                             jb      short DIGERR
CODE:0113 3C 0A                             cmp     al, 0Ah
CODE:0115 72 0C                             jb      short HAVDIG
CODE:0117 24 5F                             and     al, 1011111b    ; * Convert to upper case
CODE:0119 2C 07                             sub     al, 7
CODE:011B 3C 0A                             cmp     al, 0Ah
CODE:011D 72 10                             jb      short DIGERR
CODE:011F 3C 10                             cmp     al, 10h
CODE:0121 73 0C                             jnb     short DIGERR
CODE:0123
CODE:0123                   HAVDIG:                                 ; CODE XREF: LOCATE+115↑j
CODE:0123 D1 E3                             shl     bx, 1
CODE:0125 D1 E3                             shl     bx, 1
CODE:0127 D1 E3                             shl     bx, 1
CODE:0129 D1 E3                             shl     bx, 1
CODE:012B 0A D8                             or      bl, al
CODE:012D EB DF                             jmp     short DIGLP
CODE:012F                   ; ───────────────────────────────────────────────────────────────────────────
CODE:012F
CODE:012F                   DIGERR:                                 ; CODE XREF: LOCATE+111↑j
CODE:012F                                                           ; LOCATE+11D↑j ...
CODE:012F 80 7C FF 0D                       cmp     byte ptr [si-1], 0Dh ; * Is last char. a CR?
CODE:0133 75 BB                             jnz     short GETSEG
CODE:0135
CODE:0135                   LOADEXE:                                ; CODE XREF: LOCATE+EE↑j
CODE:0135 87 DD                             xchg    bx, bp          ; * BX has load, BP has fixup
CODE:0137 1E                                push    ds
CODE:0138 8E DB                             mov     ds, bx
CODE:013A                                   assume ds:nothing
CODE:013A 33 D2                             xor     dx, dx
CODE:013C B4 1A                             mov     ah, 1Ah
CODE:013E CD 21                             int     21h             ; DOS - SET DISK TRANSFER AREA ADDRESS
CODE:013E                                                           ; DS:DX -> disk transfer buffer
CODE:0140 1F                                pop     ds
CODE:0141                                   assume ds:DATA
CODE:0141 8B 0E F0 00                       mov     cx, SIZ_OR_PAGES
CODE:0145 BA 9B 00                          mov     dx, offset FILE1_FCB
CODE:0148 B4 27                             mov     ah, 27h         ; * Read in {actual program
CODE:0148                                                           ; * content ---} up to 64K
CODE:014A CD 21                             int     21h             ; DOS - RANDOM BLOCK READ
CODE:014A                                                           ; DS:DX -> FCB
CODE:014A                                                           ; CX = number of records to be read
CODE:014C 0A C0                             or      al, al
CODE:014E 74 03                             jz      short HAVEXE    ; * Did we get it all?
CODE:0150 E9 F8 FE                          jmp     BADEXE
CODE:0153                   ; ───────────────────────────────────────────────────────────────────────────
CODE:0153
CODE:0153                   HAVEXE:                                 ; CODE XREF: LOCATE+14E↑j
CODE:0153 83 3E F2 00 00                    cmp     RELCNT, 0       ; * Any fixups to do?
CODE:0158 74 32                             jz      short STORE
CODE:015A A1 04 01                          mov     ax, RELTAB      ; * Get position of table
CODE:015D A3 BC 00                          mov     word ptr FILE1_FCB.FCB_RN, ax
CODE:0160 BA EC 00                          mov     dx, offset MAGIC_OR_RELPT
CODE:0163 B4 1A                             mov     ah, 1Ah
CODE:0165 CD 21                             int     21h             ; DOS - SET DISK TRANSFER AREA ADDRESS
CODE:0165                                                           ; DS:DX -> disk transfer buffer
CODE:0167
CODE:0167                   RELOC:                                  ; CODE XREF: LOCATE+18A↓j
CODE:0167 B4 27                             mov     ah, 27h ; '''   ; * Read in one relocation pointer
CODE:0169 BA 9B 00                          mov     dx, offset FILE1_FCB
CODE:016C B9 04 00                          mov     cx, 4
CODE:016F CD 21                             int     21h             ; DOS - RANDOM BLOCK READ
CODE:016F                                                           ; DS:DX -> FCB
CODE:016F                                                           ; CX = number of records to be read
CODE:0171 0A C0                             or      al, al
CODE:0173 74 03                             jz      short RDCMP
CODE:0175 E9 D3 FE                          jmp     BADEXE
CODE:0178                   ; ───────────────────────────────────────────────────────────────────────────
CODE:0178
CODE:0178                   RDCMP:                                  ; CODE XREF: LOCATE+173↑j
CODE:0178 8B 3E EC 00                       mov     di, MAGIC_OR_RELPT ; * Get offset of relocation pointer
CODE:017C A1 EE 00                          mov     ax, LASTP_OR_RELSEG ; * Get segment
CODE:017F 03 C3                             add     ax, bx          ; * Bias segment with actual load segment
CODE:0181 8E C0                             mov     es, ax
CODE:0183                                   assume es:nothing
CODE:0183 26 01 2D                          add     es:[di], bp     ; * Relocate
CODE:0186 FF 0E F2 00                       dec     RELCNT          ; * Count off
CODE:018A 75 DB                             jnz     short RELOC
CODE:018C
CODE:018C                   STORE:                                  ; CODE XREF: LOCATE+158↑j
CODE:018C B4 16                             mov     ah, 16h         ; * {Create destination (.BIN/.COM) file}
CODE:018E BA C0 00                          mov     dx, offset FILE2_FCB
CODE:0191 CD 21                             int     21h             ; DOS - CREATE A DISK FILE
CODE:0191                                                           ; DS:DX -> FCB
CODE:0193 0A C0                             or      al, al
CODE:0195 75 2D                             jnz     short MKERR
CODE:0197 1E                                push    ds
CODE:0198 8E DB                             mov     ds, bx
CODE:019A                                   assume ds:nothing
CODE:019A 33 D2                             xor     dx, dx
CODE:019C B4 1A                             mov     ah, 1Ah
CODE:019E CD 21                             int     21h             ; DOS - SET DISK TRANSFER AREA ADDRESS
CODE:019E                                                           ; DS:DX -> disk transfer buffer
CODE:01A0 1F                                pop     ds
CODE:01A1                                   assume ds:DATA
CODE:01A1 C7 06 CE 00 01 00                 mov     FILE2_FCB.FCB_RC, 1 ; * {Write out .BIN/.COM file}
CODE:01A7 8B 0E F0 00                       mov     cx, SIZ_OR_PAGES
CODE:01AB BA C0 00                          mov     dx, 0C0h ; '└'
CODE:01AE B4 28                             mov     ah, 28h
CODE:01B0 CD 21                             int     21h             ; DOS - RANDOM BLOCK WRITE
CODE:01B0                                                           ; DS:DX -> FCB
CODE:01B0                                                           ; CX = number of records to be written
CODE:01B0                                                           ; if zero, truncate file to current random file position
CODE:01B2 0A C0                             or      al, al
CODE:01B4 75 08                             jnz     short WRTERR
CODE:01B6 B4 10                             mov     ah, 10h         ; * {Close output file}
CODE:01B8 BA C0 00                          mov     dx, offset FILE2_FCB
CODE:01BB CD 21                             int     21h             ; DOS - CLOSE DISK FILE
CODE:01BB                                                           ; DS:DX -> FCB
CODE:01BB                                                           ; Return: AL = 00h directory update successful
CODE:01BB                                                           ; FFh file not found in directory
CODE:01BD CB                                retf                    ; * {Return --- to PSP:0
CODE:01BD                                                           ; * --- and so exit}
CODE:01BE                   ; ───────────────────────────────────────────────────────────────────────────
CODE:01BE
CODE:01BE                   WRTERR:                                 ; CODE XREF: LOCATE+1B4↑j
CODE:01BE BA 41 00                          mov     dx, offset FULL ; "Insufficient disk space$"
CODE:01C1 E9 7D FE                          jmp     XERROR
CODE:01C4                   ; ───────────────────────────────────────────────────────────────────────────
CODE:01C4
CODE:01C4                   MKERR:                                  ; CODE XREF: LOCATE+195↑j
CODE:01C4 BA 2D 00                          mov     dx, offset DIRFULL ; "File creation error$"
CODE:01C7 E9 77 FE                          jmp     XERROR
CODE:01C7                   LOCATE          endp
CODE:01C7
CODE:01C7                   CODE            ends
CODE:01C7
DATA:000A                   ; ═══════════════════════════════════════════════════════════════════════════
DATA:000A
DATA:000A                   ; Segment type: Pure data
DATA:000A                   DATA            segment byte public 'DATA' use16
DATA:000A                                   assume cs:DATA
DATA:000A                                   ;org 0Ah
DATA:000A 46 69 6C 65 20 6E+NOTFND          db 'File not found$'    ; DATA XREF: LOCATE+3E↑o
DATA:0019 49 6E 73 75 66 66+NOROOM          db 'Insufficient memory$'
DATA:0019 69 63 69 65 6E 74+                                        ; DATA XREF: LOCATE:TOOBIG↑o
DATA:002D 46 69 6C 65 20 63+DIRFULL         db 'File creation error$'
DATA:002D 72 65 61 74 69 6F+                                        ; DATA XREF: LOCATE:MKERR↑o
DATA:0041 49 6E 73 75 66 66+FULL            db 'Insufficient disk space$'
DATA:0041 69 63 69 65 6E 74+                                        ; DATA XREF: LOCATE:WRTERR↑o
DATA:0059 46 69 78 2D 75 70+PROMPT          db 'Fix-ups needed - base segment (hex): $'
DATA:0059 73 20 6E 65 65 64+                                        ; DATA XREF: LOCATE:GETSEG↑o
DATA:007F 0D 0A 24          CRLF            db 0Dh,0Ah,'$'          ; DATA XREF: LOCATE+FE↑o
DATA:0082 46 69 6C 65 20 63+CANTFIX         db 'File cannot be converted$'
DATA:0082 61 6E 6E 6F 74 20+                                        ; DATA XREF: LOCATE:BADEXE↑o
DATA:0082 62 65 20 63 6F 6E+                                        ; LOCATE+BC↑o
DATA:009B 00 20 20 20 20 20+FILE1_FCB       FCB <0, '        ', 'EXE', 0, 0, 0, 0, 0, 0, 0>
DATA:009B 20 20 20 45 58 45+                                        ; DATA XREF: LOCATE+3↑o
DATA:009B 00 00 00 00 00 00+                                        ; LOCATE+1A↑o ...
DATA:00C0 00 20 20 20 20 20+FILE2_FCB       FCB <0, '        ', 'BIN', 0, 0, 0, 0, 0, 0, 0>
DATA:00C0 20 20 20 42 49 4E+                                        ; DATA XREF: LOCATE+1D↑o
DATA:00C0 00 00 00 00 00 00+                                        ; LOCATE+29↑o ...
DATA:00E5 05 00             INBUF           db 5, 0                 ; DATA XREF: LOCATE+F9↑o
DATA:00E5                                                           ; LOCATE+105↑o
DATA:00E7 00 00 00 00 00                    db 5 dup(0)
DATA:00EC 00 00             MAGIC_OR_RELPT  dw 0                    ; DATA XREF: LOCATE:EXELOAD↑o
DATA:00EC                                                           ; LOCATE+67↑r ...
DATA:00EE 00 00             LASTP_OR_RELSEG dw 0                    ; DATA XREF: LOCATE+98↑r
DATA:00EE                                                           ; LOCATE+17C↑r
DATA:00F0 00 00             SIZ_OR_PAGES    dw 0                    ; DATA XREF: LOCATE+88↑r
DATA:00F0                                                           ; LOCATE:WHOLEP↑w ...
DATA:00F2 00 00             RELCNT          dw 0                    ; DATA XREF: LOCATE+E0↑r
DATA:00F2                                                           ; LOCATE+E9↑r ...
DATA:00F4 00 00             HEADSIZ         dw 0                    ; DATA XREF: LOCATE+6F↑r
DATA:00F6 00 00                             dw 0
DATA:00F8 00 00             LOADLOW         dw 0
DATA:00FA 00 00             INITSS          dw 0                    ; DATA XREF: LOCATE+BF↑r
DATA:00FC 00 00             INITSP          dw 0                    ; DATA XREF: LOCATE+C2↑r
DATA:00FE 00 00                             dw 0
DATA:0100 00 00             INITIP          dw 0                    ; DATA XREF: LOCATE+CC↑r
DATA:0102 00 00             INITCS          dw 0                    ; DATA XREF: LOCATE+C6↑r
DATA:0104 00 00             RELTAB          dw 0                    ; DATA XREF: LOCATE+15A↑r
DATA:0106 00                                db    0
DATA:0107 00                                db    0
DATA:0108 00                                db    0
DATA:0109 00                                db    0
DATA:010A 00                                db    0
DATA:010B 00                                db    0
DATA:010C ??                                db    ? ;
DATA:010D ??                                db    ? ;
DATA:010E ??                                db    ? ;
DATA:010F ??                                db    ? ;
DATA:010F                   DATA            ends
DATA:010F
STACK:0000                   ; ═══════════════════════════════════════════════════════════════════════════
STACK:0000
STACK:0000                   ; Segment type: Uninitialized
STACK:0000                   STACK           segment byte stack 'STACK' use16
STACK:0000                                   assume cs:STACK
STACK:0000                                   assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
STACK:0000 ?? ?? ?? ?? ?? ??+                db 80h dup(?)
STACK:0000 ?? ?? ?? ?? ?? ??+STACK           ends
STACK:0000 ?? ?? ?? ?? ?? ??+
LOAD:0000                   ; ═══════════════════════════════════════════════════════════════════════════
LOAD:0000
LOAD:0000                   ; Segment type: Zero-length
LOAD:0000                   LOAD            segment byte public 'DATA' use16
LOAD:0000                   LOAD            ends
LOAD:0000
LOAD:0000
LOAD:0000                                   end LOCATE
